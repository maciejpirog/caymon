<html>

  <head>
    <meta charset="UTF-8"> 
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="prism.css">
    <link href="https://fonts.googleapis.com/css?family=Pacifico|Roboto" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Dancing+Script" rel="stylesheet"> 
        <script language="javascript" src="prism.js"></script>
  </head>

<body>


<div class="menux">
  <a class="menuitem" href="index.html">CayMon's home</a>
  <a class="menuitem menusel" href="tutorial.html">Tutorial</a>
  <a class="menuitem" href="caymon.html">Try it in browser</a>
  <a class="menuitem" href="https://github.com/maciejpirog/caymon">Source</a>
</div>
  
<div class="cont">
  
<div class="header">
	<img src="logo.png">
	<h2 id="hd">CayMon tutorial</h2>
      </div>
<div class="mainCont">

  <p>
    In this tutorial, we discuss the theory behind the <a href="index.html">CayMon</a> tool. Not to get too mathy (for that, read the FOSSACS'19 paper), we shamelessly intermingle the world of sets and functions with Haskell types and Haskell functions, so semantic purists are kindly asked to keep their cool.
  </p>
  
<h3>Where do monads come from?</h3>

  <p>
This is not a <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">monad</a> tutorial, so we assume that the reader is familiar with the concept, at least as it is used in programming. In Haskell, monads are defined as a type class. The one we show below is the one from Haskell's standard library stripped off some Haskelly noise (such as the <code class="language-haskell">Applicative</code> constraint):
  </p>

  <div>
      <pre><code class="language-haskell">class Monad m where
  (>>=)   :: m a -> (a -> m b) -> m b
  return  :: a -> m a</code></pre>
    </div>

  <!--
  <p>
There is an alternative definition, more in the monoids-in-the-category-of-endofunctors spirit:
    </p>
  
  <div>
    <pre><code class="language-haskell">class Functor m => Monad m where
  join    :: m (m a) -> m a
  return  :: a -> m a</code></pre>
    </div>

<p>All instances are expected to satisfy the following equations:</p>

  <div>
    <pre><code class="language-haskell">join . return == id
join . fmap return == id
join . join == join . fmap join</code></pre>
    </div>


<h3>Where do monads come from?</h3>
-->
  
  <p>
Different flavours of monads are closely related to different flavours of algebraic theories. For example, a <a href="https://link.springer.com/chapter/10.1007%2F978-3-642-99902-4_3">famous result</a> by Fred Linton says that <a href="https://en.wikipedia.org/wiki/Variety_(universal_algebra)">finitary equational theories</a> are equivalent to <a href="https://ncatlab.org/nlab/show/finitary+monad">finitary monads</a> on the category <strong>Set</strong>. For example, the list monad
  </p>

    <div>
    <pre><code class="language-haskell">data [a] = a : [a] | []</code></pre>
    </div>

  <p>
    is closely related to the theory of <a href="https://en.wikipedia.org/wiki/Monoid">monoids</a>:
  </p>

    <div>
      <pre><code class="language-haskell">Operations: +, 0
Equations:  (x+y)+z == x+(y+z),  x+0 == x,  0+x == x</code></pre>
    </div>

  <p>
The relationship is this: for a set <code class="language-haskell">A</code>, the <a href="https://en.wikipedia.org/wiki/Free_object">free</a> monoid generated by <code class="language-haskell">A</code> is given by <code class="language-haskell">[A]</code>, while the freeness gives the implementation of <code class="language-haskell">>>=</code> and <code class="language-haskell">return</code> (for a super-quick introduction, see <a href="http://www.cs.ox.ac.uk/people/samuel.staton/papers/jfp17.pdf">here</a>). The <code class="language-haskell">+</code> operation is implemented as <code class="language-haskell">++</code>, while <code class="language-haskell">0</code> as the empty list <code class="language-haskell">[]</code>.
  </p>

  <p>
The same story works for the <code class="language-haskell">Maybe</code> monad:
    </p>

    <div>
      <pre><code class="language-haskell">data Maybe a = Just a | Nothing</code></pre>
    </div>

  <p>
It arises from the theory of <a href="https://en.wikipedia.org/wiki/Pointed_set">pointed sets</a>:
  </p>

    <div>
      <pre><code class="language-haskell">Operations: ! (nullary)
Equations:  (none)</code></pre>
    </div>
  
  <p>
The free pointed set generated by a set <code class="language-haskell">A</code> is indeed <code class="language-haskell">Maybe A</code>, while the <code class="language-haskell">!</code> operation is obviously implemented as <code class="language-haskell">Nothing</code>.
  </p>

  <p>
There are many more examples. What do we gain by understanding the equational theory behind a monad? We get some operations that we can use in programming and we get to know their equational properties that we can use to reason about our programs (check out <a href="http://www.cs.ox.ac.uk/jeremy.gibbons/publications/mr.pdf">this paper</a> for a detailed explanation and many more examples).
  </p>

  <h3>Monads from equational theories... in Set</h3>

  <p>If we consider sets and functions (as in mathematics), the trick with free algebras of (finitary or otherwise well-behaved) equational theories always produces a monad. So, if you want a particular effect, just write down a bunch of operations and equations and <i>voilà</i>, a monad is born:</p>

  <!-- https://codepen.io/Thibaut/full/xjHef -->
  <p>
<div class="notepaper">
  <figure class="quote">
    <blockquote class="curly-quotes">
      <div style="font-family: 'Dancing Script', cursive; font-size:2.4em; xmargin-bottom:2em;">Grandma's recipe for monads</div>
      <div><ol><li>Start with an equational theory (a bunch of operations and equations).</li>
	  <li>For a set <code class="language-haskell">A</code>, take the set of terms over the signature with variables coming from <code class="language-haskell">A</code>.</li>
	  <li>Take the smallest <a href="https://en.wikipedia.org/wiki/Congruence_relation">congruence</a> relation that includes the equations.</li>
	  <li>Take the <a href="https://en.wikipedia.org/wiki/Equivalence_class">quotients</a> of the set of terms by the congruene. This is your monad <code class="language-haskell">M A</code>.</li><ol></div>
    </blockquote>
    <!-- figcaption class="quote-by">— Jim Rohn</figcaption -->
  </figure>
</div>
  </p>

  <p>Ok, it's fine if you happen to live in the perfect platonic world of sets and functions. But as Haskell programmers, we are not happy with the recipe. We can define terms over a signature (using <a href="http://hackage.haskell.org/package/free-5.1/docs/Control-Monad-Free.html">free monads</a>), but we cannot quotient! For example, free monoids can be expressed as lists, but throw in inverses (to get <a href="https://en.wikipedia.org/wiki/Group_(mathematics)">groups</a>) and try to implement the <a href="https://en.wikipedia.org/wiki/Free_group">free group</a> monad. Not a chance!</p>

  <p>
    So, which equational theories induce implementable monads?
    Disappointingly, we will never know in general, because this problem is
    undecidable, I think. We can, however, try to better understand some
    particular cases or some broad class of particular cases.
  </p>

  <h3>Monads from Cayley representations</h3>

  <p>
    The class of particular cases that we want to look at comes from the following theorem:
  </p>

  <div class="theorem">
  <p><strong>THEOREM</strong> <i>If an equational theory has a well-behaved Cayley representation</i> <code class="language-haskell">Rep</code><i>, the monad induced by the theory can be implemented as the type</i></p>
<div>
      <pre><code class="language-haskell">data CayMon a = C (forall x. (a -> Rep x) -> Rep x</code></pre>
    </div>
</div>

<p>
  The name <code class="language-haskell">CayMon</code> stands for "Cayley monad". We do not expand on what we mean by "well-behaved", because we promised not to be too mathy in this tutorial.</p>

<p>But what is this Cayley representation? First, let us discuss the particular case for monoids (<a href="https://en.wikipedia.org/wiki/Arthur_Cayley">Arthur Cayley</a> was more into groups, but we, Haskell programmers, cannot afford inverses). The theory of monoids can be encoded as a type class with a conventional set of equations:
</p>

  <div>
    <pre><code class="language-haskell">class Monoid a where
  unit  :: a
  comp  :: a -> a -> a

-- Instances should satisfy the following laws:
-- comp unit x = x
-- comp x unit = x
-- comp (comp x y) z = comp x (comp y z)</code></pre>
    </div>

<p>
There is one particularly fancy monoid, or rather a family of monoids:
</p>

  <div>
    <pre><code class="language-haskell">data Rep v = Rep (v -> v)

instance Monoid (Rep a) where
  unit                  = Rep (\x -> x)
  comp (Rep f) (Rep g)  = Rep (\x -> f (g x))</code></pre>
    </div>

  <p>The super-cool thing is that we can encode the behaviour of every monoid in this one:</p>

  <div>
    <pre><code class="language-haskell">toCayley :: (Monoid a) => a -> Rep a
toCayley x = Rep (\y -> comp x y)

fromCayley :: Monoid a => Rep a -> a
fromCayley (Rep f) = f unit</code></pre>
  </div>

  It is the case that <code class="language-haskell">toCayley</code> is a monoid homomorphism and that <code class="language-haskell">fromCayley . toCayley = id</code>. These two facts (+ some additional conditions that make the representation "well-behaved") are enough for the theorem above to apply.
</p>

<p>
  Evidently, <code class="language-haskell">Rep</code> is implementable in Haskell, so the theorem gives us an implementation of the monad induced by the theory of monoids. (BTW, if we inline the definition of <code class="language-haskell">Rep</code> in the definition of <code class="language-haskell">CayMon</code>, we get <code class="language-haskell">forall x. (a -> x -> x) -> x -> x</code>, the Church representation of lists, as noticed by <a href="https://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf">Ralf Hinze</a>).
</p>

<p>The idea is to generalise this to different theories and settings. For example, <code class="language-haskell">type Rep x = S -> x</code> turns out to represent state (where <code class="language-haskell">S</code> is a type of possible states), while <code class="language-haskell">type Rep x = (S -> x) -> x</code> represents backtracking with one global mutable cell.</p>



  <p>
<div class="notepaper">
  <figure class="quote">
    <blockquote class="curly-quotes">
      <div style="font-family: 'Dancing Script', cursive; font-size:2.4em; xmargin-bottom:2em;">CayMon's recipe for monads</div>
      <div><ol><li>Start with an equational theory (a bunch of operations and equations).</li>
	  <li>Come up with a well-behaved Cayley representation of the theory given by a type constructor <code class="language-haskell">Rep</code>.</li>
	  <li>Your monad for a type <code class="language-haskell">A</code> is given by the universally quantified type <code class="language-haskell">forall x. (A -> Rep x) -> Rep x</code>.</li><ol></div>
    </blockquote>
    <!-- figcaption class="quote-by">— Jim Rohn</figcaption -->
  </figure>
</div>
  </p>

  <p>A careful reader might have noticed that the shape of the monad resembles the <a href="http://hackage.haskell.org/package/kan-extensions-5.2/docs/Control-Monad-Codensity.html">codensity</a> monad. One important difference is that <code class="language-haskell">Rep</code> is a type constructor, but not necessarily a functor - however, the implementation of the monadic structure (<code class="language-haskell">return</code> and <code class="language-haskell">>>=</code>) is actually identical in the <a href="http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Cont.html">continuation</a>, codensity, and Cayley monads.</p>

<h3>Are we in a better place now?</h3>

<p>The task of coming up with an implementable representation for a given theory is not an easy one. For sure you cannot mechanise it, again, for complexity reasons. Our strategy is to reverse the question: given a type constructor <code class="language-haskell">Rep</code>, produce a theory that is represented by <code class="language-haskell">Rep</code>. We will not be able to see every such theory, just as we cannot recognise <i>every</i> theory that gives nondeterminism or state - people seem to be happy with the familiar ones: monoids and <code class="language-haskell">put</code> and <code class="language-haskell">get</code> with equations respectively.</p>

<p>Thus, the overall goal is to explore the space of types, and see what kind of effects are implementable by exploring possible implementations. The space of types is more structured than the space of all equational theories, which means that we can recognise some more or less canonical classes. For now, we have something to say about polynomials with natural coefficients, that is, types of the form</p>

  <div>
    <pre><code class="language-haskell">type Rep x = P x -> x</code></pre>
  </div>

<p>
where <code class="language-haskell">P x</code> is any type formed from products, sums, the variable <code class="language-haskell">x</code>, and natural numbers. A number <i>n</i> is understood as a type with <i>n</i> inhabitants, e.g., 0 is <code class="language-haskell">Void</code>, 1 is <code class="language-haskell">()</code> (unit), 2 is <code class="language-haskell">Bool</code>, and so on.
</p>

<h3>Enter CayMon</h3>

<p style="border:solid #777777 1px; padding:10px; border-radius:5px; background-color:#ffeeaa;">
  <strong>WARNING:</strong> CayMon is a research-level exploratory software. Reading its source code might help you understand some details, but its overall internal chaos will give you a headache. Read source code responsibly!
  </p>

</div>
</div>

</body>

</html>
